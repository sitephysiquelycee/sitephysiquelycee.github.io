<!DOCTYPE html>
<html lang="fr">
<head>
     <meta charset="UTF-8">
     <meta name="viewport" content="width=device-width, initial-scale=1.0">
     <meta name="keywords" content="physique,seconde,réfraction,réflexion totale,Snell-Descartes,hémicylindre,demi-cylindre,animation,simulation,lycée"/>
     <meta name="author" content="Anthony Laurent"/>
     <meta name="description" content="animation réfraction par un hémicylindre"/>
     <title>animation réfraction par un demi-cylindre</title>
     <style>
  
          html,
          body {
              margin: 0;
              padding: 0;
              overflow: hidden;
              background-color:lightcyan;
          }
          
          #stage{
              background-color:aliceblue;
              position:absolute;
              top:50%;
              left:50%;
              width:100%;
              height:auto;
              transform:translate(-50%, -50%);
              touch-action:pinch-zoom;
          }
                
      </style>

      <script src="snap.svg-min.js"></script>
  </head>
  <body>
  <SVG id='stage' class="orient"></SVG>
      <script>
          const w=950, h= 345;
          svg=document.getElementById('stage');
          paper=Snap("#stage");
          paper.attr({
              viewBox:[0,0,w,h].join(',')
          });

          function getPointerSVG(svg, event) {
            const svgMatrix = svg.getScreenCTM();
            return {
                x: (event.clientX - svgMatrix.e) / svgMatrix.a,
                y: (event.clientY - svgMatrix.f) / svgMatrix.d
            };
          }

          const pi=Math.PI;
          const deg= 180/pi;
          const rad=1/deg;

          const R= h/2;
          const xD=w-2*R-R/20; 
          const ctx=xD+R/1.5;

          let angle='';
          let theta_start, theta_move, theta;
          let theta_old=0;

          let indice=1.5;
          let n1=1,n2=indice;
          let i1=0;

            function permutemilieu(){
                let angle=theta*deg;
                if  (  ( Math.abs(angle)>90 ) && (  Math.abs(angle)<270 )  ){
                    i1=(theta-pi)%(2*pi);
                    return true;
                }
                else {
                    i1=(theta)%(2*pi);
                    return false;
                }
            }

            function i2(){
                if ( permutemilieu() ){
                    n1 =indice;
                    n2 = 1;
                }
                else{
                    n1 = 1;
                    n2 = indice;
                }
                return  Math.asin(n1 * Math.sin(i1) / n2);
		    }


          const fond=paper.rect(0,0,w,h).attr({
            stroke:'#443F46',
            strokeWidth:1,
            fill: "#f0e5cb"}
          );

          const socle=paper.rect(R/2,R-R/2,w/1.9,R,R/20).attr({
             fill: '#443F46'
          });

          

          class Disque{
            constructor(posX, posY, ray,colstroke,colfill){
                this.innerHTML=paper.circle(posX, posY, ray).attr({
                    strokeWidth: 1,
                    stroke: colstroke,
                    fill:colfill  
                });
            }
          }

          class Grads{
            constructor(posX,posY,taille,alpha){
               this.innerHTML=paper.line(posX, posY, posX+taille, posY).attr({
                stroke: "black",
                strokeWidth: 1  
               }).transform("r" + alpha + " ," + (ctx) + "," + R);
            }
          }

          class Textgrad{
            constructor(x,y,text){
                this.innerHTML=paper.text( x, y, text).attr({
                "font-family":"Tahoma",
                "font-size":R/22,
                "font-weight": "bold",
                fill:'#555555'
                });
            }
          }


          const grads=paper.g();
          for (let i=0;i<360;i++) grads.add(new Grads(ctx+R-.03*R,R,.03*R,i).innerHTML);

          const grads10=paper.g();
          const textg=paper.g();

          const grads5=paper.g();

          for (let j=0;j<36;j++){
            grads10.add( new Grads(ctx+R-0.09*R,R,0.09*R,10*j).innerHTML );
            if (j<=9) {angle=String(10*j);}
            else if ( (j>9) && (j<=18) ) {angle=String(90-(j-9)*10);}
            else if ( (j>18) && (j<=27) ) {angle=String((j-9)*10-90);}
            else {angle=String(170- (j-19)*10);}
            textg.add( new Textgrad(ctx-R+R*(0.97+7/8*Math.cos(10*j*rad) ) ,R*(1.015+7/8*Math.sin(10*j*rad) ) ,angle).innerHTML );
          }

          
          for (let k=0; k<72; k++){
             grads5.add( new Grads(ctx+R-0.06*R,R,0.06*R,5*k).innerHTML );
          }


          class  Hemicylindre{
               constructor(cx,cy,radius, startAngle, endAngle,strw,strcol,colfill) {
                let angle = startAngle*rad;
                if (endAngle<startAngle) endAngle+=360;
                function getPts(cx,cy,radius,angle){
                  let pt={};
                  pt.x=  cx + Math.cos(angle) * radius;
                  pt.y=  cy + Math.sin(angle) * radius;
                  return pt;
                }

                let arcpath = "M " + getPts(cx,cy,radius,angle).x  + " " +getPts(cx,cy,radius,angle).y ;
                while(angle<=endAngle*rad) {
                  arcpath +="L"+getPts(cx,cy,radius,angle).x  + " " +getPts(cx,cy,radius,angle).y;
                  angle +=rad;
                }
                let peripath=arcpath+"L"+getPts(cx,cy,radius,startAngle*rad).x  + " " +getPts(cx,cy,radius,startAngle*rad).y ;
                this.innerHTML=paper.path(peripath).attr({
                  stroke: strcol,
                  strokeWidth: strw,
                  fill: colfill
                });
            }
          }

          const lineairev2 = paper.gradient("l(0, 0, 0, 1) rgba(210,220,230,0.65)-rgba(255,255,255,0.65)");

          const hemicylindre=new Hemicylindre(  ctx, R, 7.8*R/10,270,90,2, 'rgba(210,220,230,1)', lineairev2  ).innerHTML ;


          
          const rapporteur=paper.g(
            new Disque(xD+R/1.5,R,R,'#fffaf0','#fffaf0').innerHTML,
            new Disque(xD+R/1.5,R,R/70,'black','#fffaf0').innerHTML,
            paper.g(paper.circle(xD+R/1.5,R,R/1.5),paper.circle(ctx,R,R/4),paper.circle(ctx,R,R/10),paper.line(ctx-R,R,ctx+R,R),
              paper.line(ctx,0,ctx,2*R) ).attr({
                        stroke: "black",
                        strokeWidth: 1,
                        fill:'none'  
            }),grads,grads5,grads10,textg,hemicylindre
          );

          const attrRayon={
            stroke: "#F85442",
            strokeWidth:2
          };

          const attrRayonref={
            stroke:"rgba(248,84,66,1)",
            strokeWidth:2
          }

          const attrRayonrefdash={
            stroke: "rgba(248,84,66,1)",
            strokeDasharray: '11,5,11,5',
            strokeWidth:2
          }

          const incident=paper.line(R/1.6+51*R/50,R,R/1.5+xD,R,3).attr(attrRayon);

          const reflechi=paper.g(
            paper.line(ctx,R,ctx-R,R).attr(attrRayonref),
            paper.line(ctx-R,R,R,R).attr(attrRayonrefdash)
          );  

          const refracte=paper.g(
            paper.line(ctx,R,R+ctx,R).attr({
                stroke: "rgba(248,84,66,0.8)",
                strokeWidth:2
            }),
            paper.line(ctx+R,R,xD+5*R/2,R).attr({
                stroke:"rgba(248,84,66,0.8)",
                strokeDasharray: '11,5,11,5',
                strokeWidth:2
            })
          );

          const lineairev = paper.gradient("l(0, 0, 0, 1) black-white-black");

          const Laser=paper.g(
            paper.rect(R/1.6,h/2-6*R/25,R,12*R/25,R/20).attr({
             fill: lineairev
            }),
            paper.rect(R/1.6+R,h/2-R/25,R/50,2*R/25).attr({
             fill:'#a0a0a0'
           })
          );

          class ListBox {
            constructor(x, y, wL, itemHeight, items, label, doClick) {
                const TpaperItem = [],
                    TpaperText = [],
                    TItem = [];
                const tabfunc = [];
                let _itemIndex = -1,
                    first = true;
                var group = paper.g();

                for (let i = 0; i < items.length; i++) {
                    TpaperItem[i] = paper.rect(x, i * itemHeight + y, wL, itemHeight).attr({
                        'stroke-width': 1,
                        stroke: 'black',
                        fill: 'white'
                    });
                    TpaperText[i] = paper.text(x + wL / 20, (i + .6) * itemHeight + y, items[i]).attr({
                        "font-family": "Tahoma",
                        "font-size": 18,
                        fill: 'black',
                        "dominant-baseline": "middle"
                    });

                    tabfunc[i] = function() {
                        if (first) {
                            first = false;
                        } else {
                            TpaperItem[_itemIndex].attr({
                                fill: 'white'
                            });
                            TpaperText[_itemIndex].attr('fill', 'black');
                        }
                        _itemIndex = i;
                        TpaperItem[i].attr({
                            fill: '#0078D7'
                        });
                        TpaperText[i].attr('fill', 'white')
                        group.attr('visibility', 'hidden');
                        label.attr('text', items[i])
                        doClick();
                    };

                    TItem[i] = paper.g(TpaperItem[i], TpaperText[i]).attr('cursor', 'pointer');
                    TItem[i].click(tabfunc[i]);

                    group.add(TItem[i]);
                }

                this.innerHTML = group;

                Object.defineProperties(this, {
                    "itemIndex": {
                        get: function() {
                            return _itemIndex;
                        },
                        set: function(value) {
                            _itemIndex = value;
                            TpaperItem[_itemIndex].attr({
                                fill: '#0078D7'
                            });
                            TpaperText[_itemIndex].attr('fill', 'white')
                            first = false;
                        }
                    }
                });
            }
        }

        class Combobox extends ListBox {
            constructor(x, y, wL, itemHeight, items, ind, doClick) {
                const choix = paper.text(10 + x, y + itemHeight / 2, items[ind]).attr({
                    "font-family": "Tahoma",
                    "font-size": 18,
                    fill: 'black',
                    "dominant-baseline": "middle"
                });
                super(x + 2, y + itemHeight, wL - 4, itemHeight, items, choix, doClick)
                const lineairev1 = paper.gradient("l(0, 0, 0, 1) #cfcfcf:50-#dddddd:5-#ebebeb:20-#f2f2f2:25");
                const lineairev2 = paper.gradient("l(0, 0, 0, 1) #bef6fd:20-#a7d9f5:50-#d9f0f2:15-#eaf6f2:15");
                const container = paper.rect(x, y, wL, itemHeight, 5).attr({
                    fill: lineairev1
                });
                const p = 'M' + (x + 9 * wL / 10) + ' ' + (y + itemHeight / 3) + 'L' + (x + 9 * wL / 10 + wL / 20) + ' ' + (y + itemHeight / 3) + 'L' + (x + 9 * wL / 10 + wL / 40) + ' ' + (y + 1.8 * itemHeight / 3) + 'Z';
                const sign = paper.path(p).attr({
                    fill: '#230000'
                });

                const visibilite = this.innerHTML.attr('visibility', 'hidden');

                const form = paper.g(container, sign, choix);

                function skin(order) {
                    switch (order) {
                        case (0):
                            container.attr({
                                fill: lineairev1
                            });
                            break;
                        case (1):
                            container.attr({
                                fill: lineairev2
                            });
                            break;
                    }
                }

                function handlePointerOver(e) {
                    skin(1);
                }

                function handlePointerOut(e) {
                    skin(0);
                }

                function handlePointerDown(e) {
                    visibilite.attr('visibility', 'visible');
                }

                form.node.addEventListener('pointerout',handlePointerOut);
                form.node.addEventListener('pointerover',handlePointerOver);
                form.node.addEventListener('pointerdown',handlePointerDown);
                form.node.addEventListener('pointerout',handlePointerOut);
            }
        }

        class Panel{
            constructor(x,y,wp,hp,bo){
                const tab1=[x,y,wp+x,y,wp-bo+x,bo+y,bo+x,bo+y];
                const tab2= [wp+x,y,wp-bo+x,bo+y,wp-bo+x,hp-bo+y,wp+x,hp+y];
                const tab3= [wp+x,hp+y,x,hp+y,bo+x,hp-bo+y,wp-bo+x,hp-bo+y];
                const tab4=[x,hp+y,bo+x,hp-bo+y,bo+x,bo+y,x,y];
                const panneau=paper.g(
                    paper.polyline(tab1).attr({fill:'white'}),
                    paper.polyline(tab2).attr({fill:'#A0A0A0'}),
                    paper.polyline(tab3).attr({fill: '#A0A0A0'}),
                    paper.polyline(tab4).attr({fill:'white'}),
                    paper.rect( x+bo , y+bo , wp-2*bo , hp-2*bo ).attr({fill:'#dfece4'})
                );
                this.innerHTML= panneau;
            }
        }

        function callback_list() {
            let itemindex = combo.itemIndex;
            switch (itemindex) {
                case 0:
                    indice =1.33 ;
                    break;
                case 1:
                    indice=1.36 ;
                    break;
                case 2:
                    indice=1.5;
                    break;
                case 3:
                     indice= 1.57;
                    break;
                case 4:
                     indice= 1.78;
                    break;
                case 5:
                     indice= 2.42;
                    break;    
            }

            if ( permutemilieu() ){
				n1 =indice;
		   		n2 = 1;
		  	}
			  else{
		   		n1 = 1;
				n2 = indice;
			 }
            Descartes();
          }

          function visible(bool){
            bool? (refracte.attr({visibility: "visible"})):(refracte.attr({ visibility: "hidden"}));       
          }

          function Descartes(){
            if (!permutemilieu()){
                 visible(true);
                 refracte.transform("r" + ( deg* (-theta+i2() ) ) + " ," + (ctx) + "," + R);
                 reflechi.attr({opacity:.25});
            }
            else{
                if( (Math.abs( Math.sin(i1) ) <=n2/n1) ){
                  visible(true);  
                  reflechi.attr({opacity:.25});
                  refracte.transform("r" + ( deg* (-theta+i2() +pi) )+ " ," + (ctx) + "," + R);
                }
                else {
                    visible(false);
                    reflechi.attr({opacity:1});
                }
           }
            reflechi.transform("r" + (-2*theta*deg) + " ," + (ctx) + "," + R);
          }

            const Items = ['eau', 'acétone','plexiglas/verre', '\u00C9meraude','rubis','diamant'];    
            const combo = new Combobox(R/10 , h / 45, w / 6, h / 12, Items, 2, callback_list);
            const pan=new Panel(4.63*w/5,4*h/5,w/15,w/15,3).innerHTML;
            const img=paper.image('qr_refraction.svg',4.63*w/5+3,4*h/5+3,w/15-6,w/15-6);

            const ombre = paper.filter( Snap.filter.shadow(-1, 2, .8,'#1E1E1E',.9) );
            
            const titre=paper.text(w/100,3*h/3.2,'Lois de Snell-Descartes pour la réflexion et la réfraction').attr({
                "font-family": "Papyrus",
                "font-size": 24,
                'font-weigth':'bold',
                fill: '#FFF',
                filter : ombre,
                'text-decoration':'underline'
            });
            const titre_objectif=paper.text(w/4.8,h/12,"Détermination de l'indice optique d’un milieu matériel").attr({
                "font-family":"Tahoma",
                fontSize:16,
                stroke:'#443F46', 
                'stroke-width':1,
                fill:'none',
                'text-decoration':'underline'
            });

            const copyright=paper.text(w/9,2.2*h/3,'\u00A9'+ '2022-2023 AL').attr({
                "font-family":"Tahoma",
                fontSize:10,
                fill:'white',
                'text-decoration':'underline'
            });

            let b=rapporteur.getBBox();


            function handlePointerMove(e){
                e.preventDefault();
                let p=getPointerSVG(svg,e);
                theta_move = Math.atan2(R-p.y,p.x-R-b.x);
                theta = (theta_move-theta_start+theta_old)%(2*pi);
                rapporteur.transform("r" + ( -deg*theta)  + " ," + (R+b.x) + "," + R);
                Descartes();
            }
                
            function handlePointerUp(e){
                e.preventDefault();
                rapporteur.attr({"cursor" : "grab"});
                theta_old=theta;
                rapporteur.node.removeEventListener('pointermove',handlePointerMove);
                window.removeEventListener('pointerup',handlePointerUp);
            }
                
            function handlePointerDown(e){
                e.preventDefault();
                let p=getPointerSVG(svg,e);
                rapporteur.attr({"cursor" : "grabbing"});
                theta_start=Math.atan2(R-p.y,p.x-R-b.x);
                rapporteur.node.addEventListener('pointermove',handlePointerMove);
                window.addEventListener('pointerup',handlePointerUp);
            }

            rapporteur.node.addEventListener('pointerdown',handlePointerDown);
            //let wn,hn;
            //window.addEventListener('resize',()=>{
                //if(window.matchMedia("(orientation: portrait)").matches)
               /* wn=window.innerWidth;
                hn=window.innerHeight;
                if (hn>wn){
                   // svg.style.transformOrigin=wn/2+'px '+hn/2+'px';
                   svg.style.transform= 'rotate(90deg)';
                   svg.style.transform='translate(-50%, -50%)';
          
                 
             
                 //svg.style.transform(`r${90},${hn},${wn}`);
                }
            });*/
            function orientationtype(event) {
                let x = event.accelerationIncludingGravity.x;
                let y = event.accelerationIncludingGravity.y;
                if (x<y) svg.style.transform='rotate(90deg)';// Mode portrait
                else svg.style.transform='rotate(-90deg)'; //mode paysage
            }
            window.addEventListener("devicemotion", orientationtype, true);

      </script>  
          
  </body>
</html>